<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · ClusterTrees Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ClusterTrees Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Introduction</a><ul class="internal"><li><a class="toctext" href="#Pointer-based-trees-1">Pointer based trees</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Introduction</a></li></ul><a class="edit-page" href="https://github.com/krcools/ClusterTrees.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h1><p>The API is built on top of a number of simple concepts.</p><ul><li>It is assumed that a tree is not identified with its root. If this happens to be the case in your concrete data structure, implement <a href="#ClusterTrees.root"><code>ClusterTrees.root</code></a> as a no-op.</li><li>There are a number of different iterators that a tree can produce. The simplest kind of iterators are <em>nodes</em>. Nodes can be assumed to be small and of fixed type. As a result it is cheap and efficient to store nodes in external containers for additional bookkeeping and traversal. <code>root</code> and <code>children</code> produce nodes.</li></ul><p>The core of the tree API consists of the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ClusterTrees.root" href="#ClusterTrees.root"><code>ClusterTrees.root</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">root(tree)</code></pre><p>Return a proxy for the root of the tree.</p></div></div><a class="source-link" target="_blank" href="https://github.com/krcools/ClusterTrees.jl/blob/d9d9f89a25026d8f5527518b8237aedc4d9435b7/src/trees.jl#L28-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ClusterTrees.children" href="#ClusterTrees.children"><code>ClusterTrees.children</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The expression <code>children(tree,node)</code> returns an iterator that will produce a sequence of nodes. These values do not have a lot of meaning by themselves, but can be used in conjunction with the tree object. E.g:</p><pre><code class="language-none">data(tree, node_itr)
children(tree, node_itr)</code></pre><p>In fact, the node iterators should be regarded as lightweight proxies for the underlying node and their attached data payload. The node objects themselves are of limited use for the client programmer as they are an implementation detail of the specific tree being used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/krcools/ClusterTrees.jl/blob/d9d9f89a25026d8f5527518b8237aedc4d9435b7/src/trees.jl#L43-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ClusterTrees.data" href="#ClusterTrees.data"><code>ClusterTrees.data</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">data(tree, node)</code></pre><p>Retrieve the data aka payload associated with the given node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/krcools/ClusterTrees.jl/blob/d9d9f89a25026d8f5527518b8237aedc4d9435b7/src/trees.jl#L20-L24">source</a></section><p>Based on this simple API, the following algorithms are enabled:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ClusterTrees.depthfirst" href="#ClusterTrees.depthfirst"><code>ClusterTrees.depthfirst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Traverse the tree depth first, executing the function <code>f(tree, node, level)</code> at every node. If <code>f</code> returns <code>false</code>, recursion is halted and the next node on the current level is visited.</p></div></div><a class="source-link" target="_blank" href="https://github.com/krcools/ClusterTrees.jl/blob/d9d9f89a25026d8f5527518b8237aedc4d9435b7/src/trees.jl#L67-L71">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>ClusterTrees.print_tree</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ClusterTrees.DepthFirstIterator" href="#ClusterTrees.DepthFirstIterator"><code>ClusterTrees.DepthFirstIterator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DepthFirstIterator(tree, node)</code></pre><p>Creates an iterable that when traversed visits the nodes of the subtree <code>(tree, node)</code> in depthfirst order. Children of a node are visited before that node itself.</p></div></div><a class="source-link" target="_blank" href="https://github.com/krcools/ClusterTrees.jl/blob/d9d9f89a25026d8f5527518b8237aedc4d9435b7/src/trees.jl#L119-L124">source</a></section><p>To update the tree (this includes both modifying already attached data and inserting new data):</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ClusterTrees.update!" href="#ClusterTrees.update!"><code>ClusterTrees.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update!(f, tree, state, data, target)</code></pre><p>Algorithm to update or add data to the tree. <code>router!</code> and <code>updater!</code> are user supplied functions:</p><pre><code class="language-none">route!(tree, state, target)</code></pre><p>Returns the next candidate <code>node</code> until the node for insertion is reaches. Note that this function potentially created new nodes. Arrival at the destination is indicated by returning the same node that was passed as the second argument.</p><pre><code class="language-none">f(tree, node, data)</code></pre><p>Update the destination node <code>node</code>. Typically, <code>data</code> is added in some sense to the data residing at the desitination node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/krcools/ClusterTrees.jl/blob/d9d9f89a25026d8f5527518b8237aedc4d9435b7/src/trees.jl#L90-L106">source</a></section><h2><a class="nav-anchor" id="Pointer-based-trees-1" href="#Pointer-based-trees-1">Pointer based trees</a></h2><p>Tree implementations based on pointers (or indices into Vector-backed memory buffers) are very popular and allow for the efficient implementation of most common traversal and mutation patterns. These trees support an enriched API. We only consider trees with nodes that link back to their parents.</p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>nextsibling</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.parent" href="#Base.parent"><code>Base.parent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">parent(A)</code></pre><p>Returns the &quot;parent array&quot; of an array view type (e.g., <code>SubArray</code>), or the array itself if it is not a view.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; V = view(A, 1:2, :)
2×2 view(::Array{Int64,2}, 1:2, :) with eltype Int64:
 1  2
 3  4

julia&gt; parent(V)
2×2 Array{Int64,2}:
 1  2
 3  4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/3af96bcefcb0aec559d4652fd75e1bc3fcfe99da/base/abstractarray.jl#L1037-L1060">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>firstchild</code>. Check Documenter&#39;s build log for details.</p></div></div><footer><hr/></footer></article></body></html>
